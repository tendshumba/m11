intrinsic GroupFromAxes(L::SeqEnum[AlgGenElt]: axes_check := false) -> GrpPerm, GrpMat, Map, MonStgElt, GrpMat
{  Produce the biggest possible obvious group of automorphisms of the algebra generated by the input list. }
   require not IsEmpty(L): "The argument must be a non-empty sequence.";
   A := Parent(L[1]);
   require Subalgebra(IndexedSet(L)) eq VectorSpace(A) : "The input must be a generating set of the parent algebra.";
   if axes_check then
      require forall{ x : x in L | HasMonsterFusionLaw(x)}: "The arguments must consist of axes.";
      /* perhaps having the matrix form of the Miyamoto group as an option and using that to test
      orbit representatives is the best idea here.*/
   end if; 
   F := BaseRing(A);
   // First remove twins (hence duplicate tau maps) and jordan axes( sigma maps).
   taus := [TauMapMonster(x) : x in L];
   taus_distinct := [];
   axes := [];
   jordans := [];
   sigmas := [];
   for i := 1 to #L do
      if IsIdentity(taus[i]) then
         sigma := SigmaMapMonster(L[i]);
	 Append(~jordans, L[i]);
	 Append(~sigmas, sigma);
      else
         if not taus[i] in taus_distinct then
	    Append(~taus_distinct, taus[i]);
	    Append(~axes, L[i]);
	 end if;
      end if;
   end for;
   vprintf Automorphisms, 1: "The number of sigma maps is %o.\n", #sigmas;
   Miy_p, Miy, isom, gpname, all_ax := MiyamotoGroup(axes); 
   aut := AutomorphismGroup(Miy_p);
   out := [ x : x in Generators(aut) | not IsInnerAutomorphism(x) ]; 
   gens_miy_p := SetToSequence(Generators(Miy_p));
   gens_miy := [x@isom : x in gens_miy_p]; // does Magma go sequentially?
   if IsEmpty(out) then
      if IsEmpty(sigmas) then
         return Miy_p, Miy, isom, gpname, Miy;
      end if;
      gens := gens_miy cat sigmas;
      gens_p := gens_miy_p cat [Sym(#all_ax)![Position(all_ax, all_ax[i]*sigmas[j]) : i in [1..#all_ax]] : j in [1..#sigmas]];
      perm_gp := PermutationGroup<#all_ax | gens_p>;
      mat_gp := MatrixGroup<Dimension(A), F | gens>;
      return perm_gp , mat_gp, hom<perm_gp -> mat_gp| [<perm_gp.i, mat_gp.i> : i in [1..#gens_p]]>, GroupName(perm_gp), Miy; 
   end if;
end intrinsic;

